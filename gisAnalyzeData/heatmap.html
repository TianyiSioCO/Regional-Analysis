<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agrivoltaic Analysis Map</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.31/esri/themes/light/main.css" />
  <style>
    html, body, #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
      font-family: "Segoe UI", "Microsoft Yahei", sans-serif;
      background: #0f172a;
      color: #e2e8f0;
    }
    #info-panel {
      max-width: 360px;
      padding: 1rem;
      color: #0f172a;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    #info-panel h2 { margin: 0 0 0.5rem; font-size: 1.15rem; font-weight: 700; color: #0f172a; }
    #info-panel p { margin: 0 0 0.35rem; }
    .error { padding: 12px; background: #fee2e2; color: #991b1b; border-radius: 6px; border: 1px solid #fca5a5; }

    /* Loading overlay */
    #loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 23, 42, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #loading-overlay.hidden { display: none; }
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #334155;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #loading-text {
      margin-top: 16px;
      color: #94a3b8;
      font-size: 14px;
    }

    /* Custom legend styles */
    #custom-legend {
      position: absolute;
      top: 15px;
      right: 15px;
      background: white;
      padding: 12px 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1000;
      font-family: "Segoe UI", Arial, sans-serif;
    }
    #custom-legend h4 {
      margin: 0 0 10px 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    .legend-content {
      display: flex;
      align-items: stretch;
    }
    .legend-bar {
      width: 18px;
      height: 180px;
      border-radius: 3px;
    }
    .legend-bar.dli {
      background: linear-gradient(to bottom,
        #a50026 0%,
        #d73027 12.5%,
        #f46d43 25%,
        #fdae61 37.5%,
        #fee090 50%,
        #abd9e9 62.5%,
        #74add1 75%,
        #4575b4 87.5%,
        #313695 100%
      );
    }
    .legend-bar.power {
      background: linear-gradient(to bottom,
        #006837 0%,
        #31a354 25%,
        #78c679 50%,
        #c2e699 75%,
        #ffffcc 100%
      );
    }
    .legend-labels {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      margin-left: 8px;
      font-size: 11px;
      color: #555;
    }
    .legend-labels span {
      line-height: 1;
    }

    /* Control panel */
    #control-panel {
      position: absolute;
      bottom: 30px;
      right: 15px;
      background: white;
      padding: 12px 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1000;
      font-size: 12px;
    }
    #control-panel label {
      display: block;
      margin-bottom: 6px;
      color: #333;
      font-weight: 500;
    }
    #control-panel input[type="range"] {
      width: 150px;
    }
    #control-panel .value {
      display: inline-block;
      width: 50px;
      text-align: right;
      color: #666;
    }
  </style>
</head>
<body>
  <div id="viewDiv"></div>

  <!-- Loading overlay -->
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="loading-text">Loading data...</div>
  </div>

  <!-- Custom legend -->
  <div id="custom-legend">
    <h4 id="legend-title">DLI (mol/m²/day)</h4>
    <div class="legend-content">
      <div class="legend-bar dli" id="legend-bar"></div>
      <div class="legend-labels" id="legend-labels">
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
      </div>
    </div>
  </div>

  <!-- Control panel -->
  <div id="control-panel">
    <label>
      Influence Radius: <span id="radius-value" class="value">10 km</span>
      <br/>
      <input type="range" id="radius-slider" min="5" max="30" value="10" step="1" />
    </label>
    <label>
      Opacity: <span id="opacity-value" class="value">0.85</span>
      <br/>
      <input type="range" id="opacity-slider" min="0" max="100" value="85" step="5" />
    </label>
    <label>
      Resolution: <span id="resolution-value" class="value">Medium</span>
      <br/>
      <input type="range" id="resolution-slider" min="1" max="3" value="2" step="1" />
    </label>
    <button id="refresh-btn" style="margin-top:8px;padding:6px 12px;cursor:pointer;">Refresh Render</button>
  </div>

  <div id="info-panel" class="esri-widget">
    <h2 id="map-title">Agrivoltaic Analysis Map</h2>
    <p id="map-desc">Using IDW inverse distance weighted interpolation</p>
    <p>Baseline: Standard Tracking (ST) mode</p>
  </div>

  <script type="module">
    import esriConfig from "https://js.arcgis.com/4.31/@arcgis/core/config.js";
    import Map from "https://js.arcgis.com/4.31/@arcgis/core/Map.js";
    import MapView from "https://js.arcgis.com/4.31/@arcgis/core/views/MapView.js";
    import ScaleBar from "https://js.arcgis.com/4.31/@arcgis/core/widgets/ScaleBar.js";
    import Extent from "https://js.arcgis.com/4.31/@arcgis/core/geometry/Extent.js";
    import * as projection from "https://js.arcgis.com/4.31/@arcgis/core/geometry/projection.js";
    import SpatialReference from "https://js.arcgis.com/4.31/@arcgis/core/geometry/SpatialReference.js";
    import Point from "https://js.arcgis.com/4.31/@arcgis/core/geometry/Point.js";
    import MediaLayer from "https://js.arcgis.com/4.31/@arcgis/core/layers/MediaLayer.js";
    import ImageElement from "https://js.arcgis.com/4.31/@arcgis/core/layers/support/ImageElement.js";
    import ExtentAndRotationGeoreference from "https://js.arcgis.com/4.31/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js";

    if (window.ARCGIS_API_KEY) {
      esriConfig.apiKey = window.ARCGIS_API_KEY;
    }

    const params = new URLSearchParams(window.location.search);
    // Default file: forward mode outputs points_power.csv, reverse mode outputs points_dli.csv
    const csvPath = params.get("file") || "./output/points_power.csv";

    // Global variables
    let dataPoints = [];
    // Map type: "dli" (reverse mode, displays DLI target value) or "power" (forward mode, displays power ratio)
    let mapType = "power";
    let view = null;
    let mediaLayer = null;
    let currentExtent = null;

    // Configuration parameters
    const config = {
      radiusKm: 10,       // Influence radius (kilometers) - matches 0.095° resolution
      opacity: 0.85,      // Opacity
      resolution: 2,      // Resolution level: 1=low, 2=medium, 3=high
      power: 2,           // IDW power parameter
    };

    // DLI color array (from low to high) - used for reverse mode to display DLI target values
    const dliColors = [
      [49, 54, 149],      // Deep blue
      [69, 117, 180],     // Blue
      [116, 173, 209],    // Light blue
      [171, 217, 233],    // Pale blue
      [254, 224, 144],    // Pale yellow
      [253, 174, 97],     // Orange
      [244, 109, 67],     // Deep orange
      [215, 48, 39],      // Red
      [165, 0, 38],       // Deep red
    ];

    // Power Ratio color array (from low to high) - used for forward mode to display power ratio
    const powerColors = [
      [255, 255, 204],    // Pale yellow
      [194, 230, 153],    // Light green
      [120, 198, 121],    // Green
      [49, 163, 84],      // Deep green
      [0, 104, 55],       // Dark green
    ];

    // Dynamically generated color stops (automatically calculated after loading data)
    let dliColorStops = [];
    let powerColorStops = [];
    let dataMin = 0;
    let dataMax = 100;

    // Generate color stops based on data range
    function generateColorStops(colors, min, max) {
      const stops = [];
      const step = (max - min) / (colors.length - 1);
      for (let i = 0; i < colors.length; i++) {
        stops.push({
          value: min + step * i,
          color: colors[i]
        });
      }
      return stops;
    }

    function setLoadingText(text) {
      document.getElementById("loading-text").textContent = text;
    }

    function hideLoading() {
      document.getElementById("loading-overlay").classList.add("hidden");
    }

    function showLoading() {
      document.getElementById("loading-overlay").classList.remove("hidden");
    }

    // Detect map type
    // - "dli": reverse mode output, displays dli_target_found (DLI found for given power ratio)
    // - "power": forward mode output, displays power_ratio_percent (power ratio for given DLI)
    function detectMapType(headers) {
      // Reverse mode: has dli_target_found field
      if (headers.includes("dli_target_found")) return "dli";
      // Forward mode: has power_ratio_percent field
      if (headers.includes("power_ratio_percent")) return "power";
      // Compatible with old format
      if (headers.includes("prr_percent")) return "power";
      return "power";
    }

    // Load CSV
    async function loadCsv(path) {
      const response = await fetch(path);
      if (!response.ok) throw new Error(`Failed to load CSV: ${response.status}`);
      const text = await response.text();
      const lines = text.trim().split(/\r?\n/);
      if (lines.length < 2) throw new Error("CSV content is empty");

      const headers = lines[0].split(",").map((h) => h.trim());
      const rows = lines.slice(1);
      mapType = detectMapType(headers);

      const points = [];
      let minVal = Infinity;
      let maxVal = -Infinity;

      for (const line of rows) {
        if (!line.trim()) continue;
        const cols = line.split(",");
        const record = {};
        headers.forEach((h, idx) => { record[h] = cols[idx]; });

        const lon = Number(record.longitude);
        const lat = Number(record.latitude);
        if (Number.isNaN(lon) || Number.isNaN(lat)) continue;

        // Select value to display based on map type
        let value;
        if (mapType === "dli") {
          // Reverse mode: display DLI target value found
          value = Number(record.dli_target_found) || 0;
        } else {
          // Forward mode: display power ratio
          value = Number(record.power_ratio_percent) || Number(record.prr_percent) || 0;
        }

        // Store additional info for popup
        const extraInfo = {
          baseline_power: Number(record.baseline_power_mwh) || 0,
          achieved_power: Number(record.achieved_power_mwh) || 0,
          dli_avg: Number(record.dli_avg) || 0,
        };

        points.push({ lon, lat, value, ...extraInfo });

        // Calculate min and max values
        if (value < minVal) minVal = value;
        if (value > maxVal) maxVal = value;
      }

      // Save data range and generate color stops
      dataMin = Math.floor(minVal);
      dataMax = Math.ceil(maxVal);
      console.log(`Data range: ${dataMin} - ${dataMax}, type: ${mapType}`);

      // Generate color stops based on data type
      if (mapType === "dli") {
        dliColorStops = generateColorStops(dliColors, dataMin, dataMax);
      } else {
        powerColorStops = generateColorStops(powerColors, dataMin, dataMax);
      }

      return points;
    }

    // Update legend
    function updateLegend() {
      const legendTitle = document.getElementById("legend-title");
      const legendBar = document.getElementById("legend-bar");
      const legendLabels = document.getElementById("legend-labels");
      const mapTitle = document.getElementById("map-title");
      const mapDesc = document.getElementById("map-desc");

      // Generate dynamic labels (from max to min)
      const colorStops = mapType === "dli" ? dliColorStops : powerColorStops;
      let labelsHtml = "";
      for (let i = colorStops.length - 1; i >= 0; i--) {
        const val = colorStops[i].value;
        // Decide display format based on value size
        const displayVal = Number.isInteger(val) ? val : val.toFixed(1);
        labelsHtml += `<span>${displayVal}</span>\n`;
      }

      if (mapType === "power") {
        // Forward mode: input DLI -> output power ratio
        legendTitle.textContent = "Power Ratio (%)";
        legendBar.className = "legend-bar power";
        mapTitle.textContent = "Forward Mode: DLI → Power Generation";
        mapDesc.textContent = "Displays power generation efficiency under given DLI constraints";
      } else {
        // Reverse mode: input power ratio -> output DLI
        legendTitle.textContent = "DLI (mol/m²/day)";
        legendBar.className = "legend-bar dli";
        mapTitle.textContent = "Reverse Mode: Power Generation → DLI";
        mapDesc.textContent = "Displays DLI required to achieve target power ratio";
      }

      legendLabels.innerHTML = labelsHtml;
    }

    // Calculate distance between two points (Haversine formula, returns kilometers)
    function haversineDistance(lon1, lat1, lon2, lat2) {
      const R = 6371; // Earth radius (kilometers)
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // IDW interpolation
    function idwInterpolate(lon, lat, points, radiusKm, power) {
      let weightSum = 0;
      let valueSum = 0;
      let hasNearPoint = false;

      for (const p of points) {
        const dist = haversineDistance(lon, lat, p.lon, p.lat);

        if (dist < 0.001) {
          // Very close to a point, return that point's value directly
          return p.value;
        }

        if (dist <= radiusKm) {
          hasNearPoint = true;
          const weight = 1 / Math.pow(dist, power);
          weightSum += weight;
          valueSum += weight * p.value;
        }
      }

      if (!hasNearPoint) {
        return null; // Not within influence range of any point
      }

      return valueSum / weightSum;
    }

    // Map value to color
    function valueToColor(value, colorStops) {
      if (value === null) return [0, 0, 0, 0]; // Transparent

      // Find the interval
      for (let i = 0; i < colorStops.length - 1; i++) {
        const low = colorStops[i];
        const high = colorStops[i + 1];

        if (value <= low.value) {
          return [...low.color, 255];
        }

        if (value >= low.value && value <= high.value) {
          const t = (value - low.value) / (high.value - low.value);
          return [
            Math.round(low.color[0] + t * (high.color[0] - low.color[0])),
            Math.round(low.color[1] + t * (high.color[1] - low.color[1])),
            Math.round(low.color[2] + t * (high.color[2] - low.color[2])),
            255
          ];
        }
      }

      // Exceeds maximum value
      const last = colorStops[colorStops.length - 1];
      return [...last.color, 255];
    }

    // Build spatial index (simple grid) - use plain object to avoid conflict with ArcGIS Map
    function buildSpatialIndex(points, cellSize) {
      const index = {};

      for (const p of points) {
        const cellX = Math.floor(p.lon / cellSize);
        const cellY = Math.floor(p.lat / cellSize);
        const key = `${cellX},${cellY}`;

        if (!index[key]) {
          index[key] = [];
        }
        index[key].push(p);
      }

      return { index, cellSize };
    }

    // Query nearby points from spatial index
    function queryNearbyPoints(lon, lat, spatialIndex, radiusKm) {
      const { index, cellSize } = spatialIndex;
      const searchRadius = Math.ceil(radiusKm / 111 / cellSize) + 1; // Approximate conversion

      const cellX = Math.floor(lon / cellSize);
      const cellY = Math.floor(lat / cellSize);

      const nearby = [];
      for (let dx = -searchRadius; dx <= searchRadius; dx++) {
        for (let dy = -searchRadius; dy <= searchRadius; dy++) {
          const key = `${cellX + dx},${cellY + dy}`;
          if (index[key]) {
            nearby.push(...index[key]);
          }
        }
      }

      return nearby;
    }

    // Generate IDW raster image
    async function generateIDWRaster(extent, width, height) {
      setLoadingText("Generating interpolation raster...");

      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      const imageData = ctx.createImageData(width, height);

      const colorStops = mapType === "dli" ? dliColorStops : powerColorStops;

      // Build spatial index
      const cellSize = 0.5; // Degrees
      const spatialIndex = buildSpatialIndex(dataPoints, cellSize);

      const xMin = extent.xmin;
      const xMax = extent.xmax;
      const yMin = extent.ymin;
      const yMax = extent.ymax;

      const dx = (xMax - xMin) / width;
      const dy = (yMax - yMin) / height;

      // Process in batches to avoid blocking
      const batchSize = 1000;
      let processed = 0;
      const total = width * height;

      for (let y = 0; y < height; y++) {
        const lat = yMax - y * dy; // From top to bottom

        for (let x = 0; x < width; x++) {
          const lon = xMin + x * dx;

          // Query nearby points
          const nearby = queryNearbyPoints(lon, lat, spatialIndex, config.radiusKm);

          // IDW interpolation
          const value = idwInterpolate(lon, lat, nearby, config.radiusKm, config.power);

          // Convert to color
          const color = valueToColor(value, colorStops);

          const idx = (y * width + x) * 4;
          imageData.data[idx] = color[0];
          imageData.data[idx + 1] = color[1];
          imageData.data[idx + 2] = color[2];
          imageData.data[idx + 3] = Math.round(color[3] * config.opacity);

          processed++;
        }

        // Update progress every certain number of rows
        if (y % 20 === 0) {
          setLoadingText(`Generating interpolation raster... ${Math.round(y / height * 100)}%`);
          await new Promise(r => setTimeout(r, 0)); // Allow UI update
        }
      }

      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL("image/png");
    }

    // Render IDW layer
    async function renderIDWLayer() {
      if (!view || dataPoints.length === 0) return;

      showLoading();
      setLoadingText("Calculating render extent...");

      // Get current view extent or data extent
      let extent;
      if (currentExtent) {
        extent = currentExtent;
      } else {
        // Calculate data extent
        let minLon = Infinity, maxLon = -Infinity;
        let minLat = Infinity, maxLat = -Infinity;

        for (const p of dataPoints) {
          minLon = Math.min(minLon, p.lon);
          maxLon = Math.max(maxLon, p.lon);
          minLat = Math.min(minLat, p.lat);
          maxLat = Math.max(maxLat, p.lat);
        }

        // Expand extent
        const padding = config.radiusKm / 111; // Approximate conversion to degrees
        extent = new Extent({
          xmin: minLon - padding,
          xmax: maxLon + padding,
          ymin: minLat - padding,
          ymax: maxLat + padding,
          spatialReference: { wkid: 4326 }
        });
        currentExtent = extent;
      }

      // Determine pixel size based on resolution setting
      const resolutionFactors = { 1: 400, 2: 600, 3: 900 };
      const baseSize = resolutionFactors[config.resolution] || 600;

      const aspectRatio = (extent.xmax - extent.xmin) / (extent.ymax - extent.ymin);
      let width, height;
      if (aspectRatio > 1) {
        width = baseSize;
        height = Math.round(baseSize / aspectRatio);
      } else {
        height = baseSize;
        width = Math.round(baseSize * aspectRatio);
      }

      // Generate IDW raster
      const imageUrl = await generateIDWRaster(extent, width, height);

      // Remove old layer
      if (mediaLayer) {
        view.map.remove(mediaLayer);
      }

      // Create new MediaLayer
      const imageElement = new ImageElement({
        image: imageUrl,
        georeference: new ExtentAndRotationGeoreference({
          extent: extent
        })
      });

      mediaLayer = new MediaLayer({
        source: [imageElement],
        title: "IDW Interpolation",
        opacity: 1
      });

      view.map.add(mediaLayer, 0); // Add to bottom layer

      hideLoading();
    }

    // Initialize map
    async function initMap() {
      setLoadingText("Loading CSV data...");

      try {
        dataPoints = await loadCsv(csvPath);

        if (dataPoints.length === 0) {
          throw new Error("No valid data points found");
        }

        console.log(`Loaded ${dataPoints.length} points, type: ${mapType}`);
        updateLegend();

        setLoadingText("Initializing map...");

        // Calculate data center
        let sumLon = 0, sumLat = 0;
        for (const p of dataPoints) {
          sumLon += p.lon;
          sumLat += p.lat;
        }
        const centerLon = sumLon / dataPoints.length;
        const centerLat = sumLat / dataPoints.length;

        const map = new Map({ basemap: "gray-vector" });

        view = new MapView({
          container: "viewDiv",
          map,
          center: [centerLon, centerLat],
          zoom: 7,
        });

        view.ui.add(new ScaleBar({ view, style: "line", unit: "dual" }), { position: "bottom-left" });
        view.ui.add("info-panel", "top-left");

        await view.when();

        // Render IDW
        await renderIDWLayer();

        // Navigate to data extent
        if (currentExtent) {
          view.goTo(currentExtent.expand(1.2), { animate: false });
        }

      } catch (error) {
        console.error(error);
        hideLoading();
        document.getElementById("viewDiv").innerHTML =
          `<div class="error" style="margin:20px;">${error.message}</div>`;
      }
    }

    // Bind control panel events
    function setupControls() {
      const radiusSlider = document.getElementById("radius-slider");
      const radiusValue = document.getElementById("radius-value");
      const opacitySlider = document.getElementById("opacity-slider");
      const opacityValue = document.getElementById("opacity-value");
      const resolutionSlider = document.getElementById("resolution-slider");
      const resolutionValue = document.getElementById("resolution-value");
      const refreshBtn = document.getElementById("refresh-btn");

      radiusSlider.addEventListener("input", () => {
        config.radiusKm = parseInt(radiusSlider.value);
        radiusValue.textContent = `${config.radiusKm} km`;
      });

      opacitySlider.addEventListener("input", () => {
        config.opacity = parseInt(opacitySlider.value) / 100;
        opacityValue.textContent = config.opacity.toFixed(2);
      });

      const resLabels = { 1: "Low", 2: "Medium", 3: "High" };
      resolutionSlider.addEventListener("input", () => {
        config.resolution = parseInt(resolutionSlider.value);
        resolutionValue.textContent = resLabels[config.resolution];
      });

      refreshBtn.addEventListener("click", async () => {
        await renderIDWLayer();
      });
    }

    // Start application
    setupControls();
    initMap();
  </script>
</body>
</html>
