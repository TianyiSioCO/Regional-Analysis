<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agrivoltaic Analysis Map</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.31/esri/themes/light/main.css" />
  <style>
    html, body, #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
      font-family: "Segoe UI", "Microsoft Yahei", sans-serif;
      background: #0f172a;
      color: #e2e8f0;
    }
    #info-panel {
      max-width: 360px;
      padding: 1rem;
      color: #0f172a;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    #info-panel h2 { margin: 0 0 0.5rem; font-size: 1.15rem; font-weight: 700; color: #0f172a; }
    #info-panel p { margin: 0 0 0.35rem; }
    .error { padding: 12px; background: #fee2e2; color: #991b1b; border-radius: 6px; border: 1px solid #fca5a5; }

    /* Loading */
    #loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 23, 42, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #loading-overlay.hidden { display: none; }
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #334155;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #loading-text {
      margin-top: 16px;
      color: #94a3b8;
      font-size: 14px;
    }

    /* Image custom */
    #custom-legend {
      position: absolute;
      top: 15px;
      right: 15px;
      background: white;
      padding: 12px 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1000;
      font-family: "Segoe UI", Arial, sans-serif;
    }
    #custom-legend h4 {
      margin: 0 0 10px 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    .legend-content {
      display: flex;
      align-items: stretch;
    }
    .legend-bar {
      width: 18px;
      height: 180px;
      border-radius: 3px;
    }
    .legend-bar.dli {
      background: linear-gradient(to bottom,
        #fde725 0%,
        #6ece58 12.5%,
        #35b779 25%,
        #1f9e89 37.5%,
        #26828e 50%,
        #31688e 62.5%,
        #3e4989 75%,
        #482878 87.5%,
        #440154 100%
      );
    }
    .legend-bar.power {
      background: linear-gradient(to bottom,
        #fde725 0%,
        #6ece58 12.5%,
        #35b779 25%,
        #1f9e89 37.5%,
        #26828e 50%,
        #31688e 62.5%,
        #3e4989 75%,
        #482878 87.5%,
        #440154 100%
      );
    }
    .legend-labels {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      margin-left: 8px;
      font-size: 11px;
      color: #555;
    }
    .legend-labels span {
      line-height: 1;
    }

    /* Control panel */
    #control-panel {
      position: absolute;
      bottom: 30px;
      right: 15px;
      background: white;
      padding: 12px 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      z-index: 1000;
      font-size: 12px;
    }
    #control-panel label {
      display: block;
      margin-bottom: 6px;
      color: #333;
      font-weight: 500;
    }
    #control-panel input[type="range"] {
      width: 150px;
    }
    #control-panel .value {
      display: inline-block;
      width: 50px;
      text-align: right;
      color: #666;
    }
  </style>
</head>
<body>
  <div id="viewDiv"></div>

  <!-- Loading notification -->
  <div id="loading-overlay">
    <div class="spinner"></div>
    <div id="loading-text">Loading data...</div>
  </div>

  <!-- custom -->
  <div id="custom-legend">
    <h4 id="legend-title">DLI (mol/m²/day)</h4>
    <div class="legend-content">
      <div class="legend-bar dli" id="legend-bar"></div>
      <div class="legend-labels" id="legend-labels">
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
        <span>-</span>
      </div>
    </div>
  </div>

  <!-- Control panel -->
  <div id="control-panel">
    <label>
      Radius: <span id="radius-value" class="value">150 km</span>
      <br/>
      <input type="range" id="radius-slider" min="10" max="300" value="150" step="10" />
    </label>
    <label>
      Opacity: <span id="opacity-value" class="value">0.85</span>
      <br/>
      <input type="range" id="opacity-slider" min="0" max="100" value="85" step="5" />
    </label>
    <label>
      Resolution: <span id="resolution-value" class="value">700</span>
      <br/>
      <input type="range" id="resolution-slider" min="400" max="1200" value="700" step="100" />
    </label>
    <button id="refresh-btn" style="margin-top:8px;padding:6px 12px;cursor:pointer;">Refresh Render</button>
  </div>

  <div id="info-panel" class="esri-widget">
    <h2 id="map-title">Agrivoltaic Analysis Map</h2>
    <p id="map-desc">IDW (Inverse Distance Weighting) interpolation</p>
    <p>Baseline: Standard Tracking (ST) mode</p>
  </div>

  <script type="module">
    import esriConfig from "https://js.arcgis.com/4.31/@arcgis/core/config.js";
    import Map from "https://js.arcgis.com/4.31/@arcgis/core/Map.js";
    import MapView from "https://js.arcgis.com/4.31/@arcgis/core/views/MapView.js";
    import ScaleBar from "https://js.arcgis.com/4.31/@arcgis/core/widgets/ScaleBar.js";
    import Extent from "https://js.arcgis.com/4.31/@arcgis/core/geometry/Extent.js";
    import * as projection from "https://js.arcgis.com/4.31/@arcgis/core/geometry/projection.js";
    import SpatialReference from "https://js.arcgis.com/4.31/@arcgis/core/geometry/SpatialReference.js";
    import Point from "https://js.arcgis.com/4.31/@arcgis/core/geometry/Point.js";
    import MediaLayer from "https://js.arcgis.com/4.31/@arcgis/core/layers/MediaLayer.js";
    import ImageElement from "https://js.arcgis.com/4.31/@arcgis/core/layers/support/ImageElement.js";
    import ExtentAndRotationGeoreference from "https://js.arcgis.com/4.31/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js";

    if (window.ARCGIS_API_KEY) {
      esriConfig.apiKey = window.ARCGIS_API_KEY;
    }

    const params = new URLSearchParams(window.location.search);
    // read：forward output is points_power.csv，backward output is points_dli.csv
    const csvPath = params.get("file") || "./output/points_power.csv";

    // variables
    let dataPoints = [];
    let projectedPoints = [];
    // Map type: dli (reverse) or power (forward，%PRR)
    let mapType = "power";
    let view = null;
    let mediaLayer = null;
    let currentExtent = null;
    let rasterExtent = null;

    // Configurations
    const config = {
      radiusKm: 150,      // influence radius（km), if showing dots
      opacity: 0.85,      // opacity, smaller to shown state boundaries
      resolution: 700,    // resolution
      power: 2,           // IDW 
    };

    const PROJECTED_SR = new SpatialReference({ wkid: 3857 });

    // Viridis (low to high: purple→blue→green→yellow)
    const dliColors = [
      [68, 1, 84],
      [72, 40, 120],
      [62, 74, 137],
      [49, 104, 142],
      [38, 130, 142],
      [31, 158, 137],
      [53, 183, 121],
      [110, 206, 88],
      [253, 231, 37],
    ];

    // Power Ratio (low to high：purple→blue→green→yellow)
    const powerColors = [
      [68, 1, 84],
      [72, 40, 120],
      [62, 74, 137],
      [49, 104, 142],
      [38, 130, 142],
      [31, 158, 137],
      [53, 183, 121],
      [110, 206, 88],
      [253, 231, 37],
    ];

    // color stop (auto)
    let dliColorStops = [];
    let powerColorStops = [];
    let dataMin = 0;
    let dataMax = 100;

    // legend range based on min/max
    function generateColorStops(colors, min, max) {
      const stops = [];
      const step = (max - min) / (colors.length - 1);
      for (let i = 0; i < colors.length; i++) {
        stops.push({
          value: min + step * i,
          color: colors[i]
        });
      }
      return stops;
    }

    function setLoadingText(text) {
      document.getElementById("loading-text").textContent = text;
    }

    function hideLoading() {
      document.getElementById("loading-overlay").classList.add("hidden");
    }

    function showLoading() {
      document.getElementById("loading-overlay").classList.remove("hidden");
    }

    function planarDistance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }

    async function projectPoints(points) {
      await projection.load();

      return points
        .map((p) => {
          const geoPoint = new Point({
            longitude: p.lon,
            latitude: p.lat,
            spatialReference: { wkid: 4326 }
          });

          const projected = projection.project(geoPoint, PROJECTED_SR);
          if (!projected) return null;
          return { x: projected.x, y: projected.y, value: p.value };
        })
        .filter(Boolean);
    }

    function computeGeoExtent(points) {
      let minLon = Infinity, maxLon = -Infinity;
      let minLat = Infinity, maxLat = -Infinity;

      for (const p of points) {
        minLon = Math.min(minLon, p.lon);
        maxLon = Math.max(maxLon, p.lon);
        minLat = Math.min(minLat, p.lat);
        maxLat = Math.max(maxLat, p.lat);
      }

      const padding = config.radiusKm / 111; // to degrees
      return new Extent({
        xmin: minLon - padding,
        xmax: maxLon + padding,
        ymin: minLat - padding,
        ymax: maxLat + padding,
        spatialReference: { wkid: 4326 }
      });
    }

    function computeRasterExtent(points) {
      let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;

      for (const p of points) {
        xmin = Math.min(xmin, p.x);
        ymin = Math.min(ymin, p.y);
        xmax = Math.max(xmax, p.x);
        ymax = Math.max(ymax, p.y);
      }

      const pad = config.radiusKm * 1000;
      return new Extent({
        xmin: xmin - pad,
        ymin: ymin - pad,
        xmax: xmax + pad,
        ymax: ymax + pad,
        spatialReference: PROJECTED_SR
      });
    }

    // map type:
    // - dli: reverse output，show dli_target_found (at given power ratio)
    // - power: forward output，show power_ratio_percent (at given DLI)
    function detectMapType(headers) {
      // reverse: if include dli_target_found 
      if (headers.includes("dli_target_found")) return "dli";
      // forward: if include power_ratio_percent
      if (headers.includes("power_ratio_percent")) return "power";
      // accept PRR
      if (headers.includes("prr_percent")) return "power";
      return "power";
    }

    // load CSV
    async function loadCsv(path) {
      const response = await fetch(path);
      if (!response.ok) throw new Error(`Failed to load CSV: ${response.status}`);
      const text = await response.text();
      const lines = text.trim().split(/\r?\n/);
      if (lines.length < 2) throw new Error("CSV content is empty");

      const headers = lines[0].split(",").map((h) => h.trim());
      const rows = lines.slice(1);
      mapType = detectMapType(headers);

      const points = [];
      let minVal = Infinity;
      let maxVal = -Infinity;

      for (const line of rows) {
        if (!line.trim()) continue;
        const cols = line.split(",");
        const record = {};
        headers.forEach((h, idx) => { record[h] = cols[idx]; });

        const lon = Number(record.longitude);
        const lat = Number(record.latitude);
        if (Number.isNaN(lon) || Number.isNaN(lat)) continue;

        // show results based on map type
        let value;
        if (mapType === "dli") {
          // reverse: show DLI target found
          value = Number(record.dli_target_found) || 0;
        } else {
          // forward: show power ratio 
          value = Number(record.power_ratio_percent) || Number(record.prr_percent) || 0;
        }

        // save additional info for popup
        const extraInfo = {
          baseline_power: Number(record.baseline_power_mwh) || 0,
          achieved_power: Number(record.achieved_power_mwh) || 0,
          dli_avg: Number(record.dli_avg) || 0,
        };

        points.push({ lon, lat, value, ...extraInfo });

        // calculate min/max
        if (value < minVal) minVal = value;
        if (value > maxVal) maxVal = value;
      }

      // save data range
      dataMin = Math.floor(minVal);
      dataMax = Math.ceil(maxVal);
      console.log(`Data range: ${dataMin} - ${dataMax}, type: ${mapType}`);

      // color stop pts
      if (mapType === "dli") {
        dliColorStops = generateColorStops(dliColors, dataMin, dataMax);
      } else {
        powerColorStops = generateColorStops(powerColors, dataMin, dataMax);
      }

      return points;
    }

    // update image
    function updateLegend() {
      const legendTitle = document.getElementById("legend-title");
      const legendBar = document.getElementById("legend-bar");
      const legendLabels = document.getElementById("legend-labels");
      const mapTitle = document.getElementById("map-title");
      const mapDesc = document.getElementById("map-desc");

      // from max to min
      const colorStops = mapType === "dli" ? dliColorStops : powerColorStops;
      let labelsHtml = "";
      for (let i = colorStops.length - 1; i >= 0; i--) {
        const val = colorStops[i].value;
        // decide display based on value
        const displayVal = Number.isInteger(val) ? val : val.toFixed(1);
        labelsHtml += `<span>${displayVal}</span>\n`;
      }

      if (mapType === "power") {
        // forward: input DLI -> output power ratio
        legendTitle.textContent = "Power Ratio (%)";
        legendBar.className = "legend-bar power";
        mapTitle.textContent = "Forward Mode: DLI → Power Ratio";
        mapDesc.textContent = "Shows the power ratio under a given DLI constraint.";
      } else {
        // backward: input power ratio -> output DLI
        legendTitle.textContent = "DLI (mol/m²/day)";
        legendBar.className = "legend-bar dli";
        mapTitle.textContent = "Reverse Mode: Power Ratio → DLI";
        mapDesc.textContent = "Shows the DLI required to reach the target power ratio.";
      }

      legendLabels.innerHTML = labelsHtml;
    }

    // IDW interpolation
    function idwInterpolate(x, y, points, radiusMeters, power) {
      let weightSum = 0;
      let valueSum = 0;

      for (const p of points) {
        const dist = planarDistance(x, y, p.x, p.y);

        if (dist < 1) {
          // if close to one pt，return this pt's value
          return p.value;
        }

        if (dist <= radiusMeters) {
          const weight = 1 / Math.pow(dist, power);
          weightSum += weight;
          valueSum += weight * p.value;
        }
      }

      return weightSum ? valueSum / weightSum : null;
    }

    // value to color
    function valueToColor(value, colorStops) {
      if (value === null) return [0, 0, 0, 0]; // opacity

      // find range
      for (let i = 0; i < colorStops.length - 1; i++) {
        const low = colorStops[i];
        const high = colorStops[i + 1];

        if (value <= low.value) {
          return [...low.color, 255];
        }

        if (value >= low.value && value <= high.value) {
          const t = (value - low.value) / (high.value - low.value);
          return [
            Math.round(low.color[0] + t * (high.color[0] - low.color[0])),
            Math.round(low.color[1] + t * (high.color[1] - low.color[1])),
            Math.round(low.color[2] + t * (high.color[2] - low.color[2])),
            255
          ];
        }
      }

      // over maximum
      const last = colorStops[colorStops.length - 1];
      return [...last.color, 255];
    }

    // spacial index (simple grid) avoid conflicts with ArcGIS Map
    function buildSpatialIndex(points, cellSize) {
      const index = {};

      for (const p of points) {
        const cellX = Math.floor(p.x / cellSize);
        const cellY = Math.floor(p.y / cellSize);
        const key = `${cellX},${cellY}`;

        if (!index[key]) {
          index[key] = [];
        }
        index[key].push(p);
      }

      return { index, cellSize };
    }

    // query pts with spacial index
    function queryNearbyPoints(x, y, spatialIndex, radiusMeters) {
      const { index, cellSize } = spatialIndex;
      const searchRadius = Math.ceil(radiusMeters / cellSize) + 1;

      const cellX = Math.floor(x / cellSize);
      const cellY = Math.floor(y / cellSize);

      const nearby = [];
      for (let dx = -searchRadius; dx <= searchRadius; dx++) {
        for (let dy = -searchRadius; dy <= searchRadius; dy++) {
          const key = `${cellX + dx},${cellY + dy}`;
          if (index[key]) {
            nearby.push(...index[key]);
          }
        }
      }

      return nearby;
    }

    // generate IDW raster
    async function generateIDWRaster(extent, width, height) {
      setLoadingText("Generating IDW raster...");

      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext("2d");
      const imageData = ctx.createImageData(width, height);

      const colorStops = mapType === "dli" ? dliColorStops : powerColorStops;

      // build spacial index
      const radiusMeters = config.radiusKm * 1000;
      const cellSize = Math.max(radiusMeters / 2, 1000);
      const spatialIndex = buildSpatialIndex(projectedPoints, cellSize);

      const xMin = extent.xmin;
      const xMax = extent.xmax;
      const yMin = extent.ymin;
      const yMax = extent.ymax;

      const dx = (xMax - xMin) / width;
      const dy = (yMax - yMin) / height;

      // batch processing
      const batchSize = 1000;
      let processed = 0;
      const total = width * height;
      let nullCount = 0;

      for (let y = 0; y < height; y++) {
        const py = yMax - y * dy; // from top to bottom

        for (let x = 0; x < width; x++) {
          const px = xMin + x * dx;

          // query nearby pts
          const nearby = queryNearbyPoints(px, py, spatialIndex, radiusMeters);

          // IDW interpolation
          const value = idwInterpolate(px, py, nearby, radiusMeters, config.power);
          if (value === null) nullCount++;

          // convert to colors
          const color = valueToColor(value, colorStops);

          const idx = (y * width + x) * 4;
          imageData.data[idx] = color[0];
          imageData.data[idx + 1] = color[1];
          imageData.data[idx + 2] = color[2];
          imageData.data[idx + 3] = Math.round(color[3] * config.opacity);

          processed++;
        }

        // update
        if (y % 20 === 0) {
          setLoadingText(`Generating IDW raster... ${Math.round(y / height * 100)}%`);
          await new Promise(r => setTimeout(r, 0)); // UI update
        }
      }

      ctx.putImageData(imageData, 0, 0);

      const nullRatio = total ? nullCount / total : 0;
      if (nullRatio > 0.98) {
        console.warn(
          `IDW raster has ${Math.round(nullRatio * 100)}% pixels with no data; radius may be too small (current ${config.radiusKm}km)`
        );
      }
      return canvas.toDataURL("image/png");
    }

    // render IDW layer
    async function renderIDWLayer() {
      if (!view || dataPoints.length === 0 || projectedPoints.length === 0) return;

      showLoading();
      setLoadingText("Computing render extent...");

      currentExtent = computeGeoExtent(dataPoints);
      rasterExtent = computeRasterExtent(projectedPoints);

      // generate IDW raster
      const size = config.resolution;
      const imageUrl = await generateIDWRaster(rasterExtent, size, size);

      // remove old layer
      if (mediaLayer) {
        view.map.remove(mediaLayer);
      }

      // create new MediaLayer
      const imageElement = new ImageElement({
        image: imageUrl,
        georeference: new ExtentAndRotationGeoreference({
          extent: rasterExtent
        })
      });

      mediaLayer = new MediaLayer({
        source: [imageElement],
        title: "IDW Interpolation",
        opacity: 1
      });

      view.map.add(mediaLayer, 0); // add to the bottom layer

      hideLoading();
    }

    // initialize map
    async function initMap() {
      setLoadingText("Loading CSV data...");

      try {
        dataPoints = await loadCsv(csvPath);

        if (dataPoints.length === 0) {
          throw new Error("No valid data points found");
        }

        setLoadingText("Projecting coordinates...");
        projectedPoints = await projectPoints(dataPoints);

        if (projectedPoints.length === 0) {
          throw new Error("No valid projected points found");
        }

        console.log(`Loaded ${dataPoints.length} points, type: ${mapType}`);
        updateLegend();

        setLoadingText("Initializing map...");

        // data center
        let sumLon = 0, sumLat = 0;
        for (const p of dataPoints) {
          sumLon += p.lon;
          sumLat += p.lat;
        }
        const centerLon = sumLon / dataPoints.length;
        const centerLat = sumLat / dataPoints.length;

        const map = new Map({ basemap: "gray-vector" });

        view = new MapView({
          container: "viewDiv",
          map,
          center: [centerLon, centerLat],
          zoom: 7,
        });

        view.ui.add(new ScaleBar({ view, style: "line", unit: "dual" }), { position: "bottom-left" });
        view.ui.add("info-panel", "top-left");

        await view.when();

        // render IDW
        await renderIDWLayer();

        // data range
        if (currentExtent) {
          view.goTo(currentExtent.expand(1.2), { animate: false });
        }

      } catch (error) {
        console.error(error);
        hideLoading();
        document.getElementById("viewDiv").innerHTML =
          `<div class="error" style="margin:20px;">${error.message}</div>`;
      }
    }

    // control panel events
    function setupControls() {
      const radiusSlider = document.getElementById("radius-slider");
      const radiusValue = document.getElementById("radius-value");
      const opacitySlider = document.getElementById("opacity-slider");
      const opacityValue = document.getElementById("opacity-value");
      const resolutionSlider = document.getElementById("resolution-slider");
      const resolutionValue = document.getElementById("resolution-value");
      const refreshBtn = document.getElementById("refresh-btn");

      radiusSlider.addEventListener("input", () => {
        config.radiusKm = parseInt(radiusSlider.value);
        radiusValue.textContent = `${config.radiusKm} km`;
      });

      opacitySlider.addEventListener("input", () => {
        config.opacity = parseInt(opacitySlider.value) / 100;
        opacityValue.textContent = config.opacity.toFixed(2);
      });

      resolutionSlider.addEventListener("input", () => {
        config.resolution = parseInt(resolutionSlider.value);
        resolutionValue.textContent = config.resolution;
      });

      refreshBtn.addEventListener("click", async () => {
        await renderIDWLayer();
      });
    }

    // initiate
    setupControls();
    initMap();
  </script>
</body>
</html>
